小蓝在一个 nn 行 mm 列的方格图中玩一个游戏。

开始时，小蓝站在方格图的左上角，即第 11 行第 11 列。

小蓝可以在方格图上走动，走动时，如果当前在第 rr 行第 cc 列，他不能走到行号比 rr 小的行，也不能走到列号比 cc 小的列。同时，他一步走的直线距离不超过 33。

例如，如果当前小蓝在第 33 行第 55 列，他下一步可以走到第 33 行第 66 列、第 33 行第 77 列、第 33 行第 88 列、第 44 行第 55 列、第 44 行第 66 列、第 44 行第 77 列、第 55 行第 55 列、第 55 行第 66 列、第 66 行第 55 列之一。

小蓝最终要走到第 nn 行第 mm 列。

在图中，有的位置有奖励，走上去即可获得，有的位置有惩罚，走上去就要接受惩罚。奖励和惩罚最终抽象成一个权值，奖励为正，惩罚为负。

小蓝希望，从第 11 行第 11 列走到第 nn 行第 mm 列后，总的权值和最大。请问最大是多少？

#include<iostream>
#include<algorithm>
using namespace std;
#define maxint 100
int dp[104][104];
int main()
{
	int x, y;
	int k, l;
	cin >> x >> y;
	int i, j;
	for (i = 3; i <= x+2; i++)
		for (j = 3; j <= y+2; j++)
			cin >> dp[i][j];


	for (i = 0; i < 103; i++)
	{dp[0][i] = -10001; dp[i][0] = -10001; dp[1][i] = -10001; dp[i][1] = -10001; dp[2][i] = -10001; dp[i][2] = -10001;
	}
	
	//cout <<endl<< dp[3][3] << " ";
	int mx;
	for (i = 3; i <= x + 2; i++)
	{
		for (j = 3; j <= y + 2; j++)
		{
			if (i == 3 && j == 3) continue;
			mx = max({ dp[i - 1][j], dp[i - 2][j], dp[i - 3][j], dp[i][j - 1],dp[i][j - 2],dp[i][j - 3],dp[i - 1][j - 2],dp[i - 1][j - 1],dp[i - 2][j - 1] });
			dp[i][j] =mx+ dp[i][j];
			//cout << dp[i][j] << " ";
		}
		//cout << endl;
	}
	cout << dp[x + 2][y + 2];
	return 0;
}
